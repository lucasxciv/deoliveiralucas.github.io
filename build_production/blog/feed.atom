<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>@lucasxciv</title>
    <link href="https://lucasxciv.dev/blog" />
    <link type="application/atom+xml" rel="self" href="https://lucasxciv.dev/blog/feed.atom" />
    <updated>2024-10-03T00:34:35+00:00</updated>
    <id>https://lucasxciv.dev/blog/feed.atom</id>
    <author>
        <name>Lucas de Oliveira</name>
    </author>
                <entry>
    <id>https://lucasxciv.dev/blog/2019-08-12-testando-novas-funcionalidades-do-php-7-4</id>
    <link type="text/html" rel="alternate" href="https://lucasxciv.dev/blog/2019-08-12-testando-novas-funcionalidades-do-php-7-4" />
    <title>Testando Novas Funcionalidades do PHP 7.4</title>
    <published>2019-08-12T00:00:00+00:00</published>
    <updated>2019-08-12T00:00:00+00:00</updated>
    <author>
        <name>de Oliveira, Lucas</name>
    </author>
    <summary type="html">Nesse post mostro como fiz para testar as novas funcionalidades da versão 7.4 do PHP ainda em fase beta. Algumas dessas funcionalidades são Typed Properties e Spread Operator, além disso, apresento como fiz para configurar o ambiente usando Docker....</summary>
    <content type="html"><![CDATA[
        <p>Neste post apresento como fiz para testar as novas funcionalidades da versão 7.4 do PHP que ainda está em fase beta (a versão estável deve ser lançado em novembro de 2019). Como exemplo, criei uma implementação bem simples de um "blog" com cadastro e consulta de posts, sendo os dados armazenados em arquivos <em>JSON</em>. Começo comentando um pouco sobre algumas das novas funcionalidades do PHP 7.4 que foi aplicado no exemplo que desenvolvi, em seguida descrevo como fiz para configurar o ambiente e então concluo com um link para o código completo dos testes que fiz no meu Github.</p>

<h2><em>Typed Properties</em> - Criando as classes para armazenar os posts</h2>

<p>Começando então pelo sistema de tipagem, que no PHP 7.4 foi melhorado com a adição do <em>typed properties</em>, com essa funcionalidade agora é possível definir os tipos das propriedades em classes, sendo necessário informar o modificador de acesso: <code>public</code>, <code>protected</code> ou <code>private</code>; ou <code>var</code>. Para tipos primitivos essa funcionalidade deve funcionar da mesma forma que a de passagem por parâmetro em métodos e funções, por exemplo, por padrão se for definido um tipo <code>int</code> e for passado uma <code>string</code>, o PHP vai tentar converter o tipo de <code>string</code> para <code>int</code>; porém se você quiser desabilitar esse tipo de comportamento e lançar um <code>Fatal Error</code> quando isso acontecer, basta utilizar o <code>declare(strict_types=1)</code>.</p>

<p>Para quem usa IDE ou algum editor que tem autocomplete, essa funcionalidade vai ajudar a identificar o tipo sem precisar utilizar o <code>@var</code> no PHPDoc blocks das propriedades da classe.</p>

<p>Com isso, a classe <code>Post</code> e <code>Author</code> ficou da seguinte forma:</p>

<ul>
<li>Post.php</li>
</ul>

<pre><code class="language-php">&lt;?php

class Post
{
    public int $id;
    public string $title;
    public string $content;
    public DateTimeImmutable $postedAt;
    public Author $author;
}
</code></pre>

<ul>
<li>Author.php</li>
</ul>

<pre><code class="language-php">&lt;?php

class Author
{
    public int $id;
    public string $name;
    public ?string $profile;
}
</code></pre>

<h2><em>Spread Operator</em> em <em>arrays</em> - Adicionando um novo post</h2>

<p>Agora é possível utilizar o <em>spread operator</em> em <em>arrays</em>, dessa forma podemos usá-lo para adicionar um novo post no início do <em>array</em> de posts, tendo um resultado igual ao da função <code>array_unshift</code>.</p>

<pre><code class="language-php">function appendPosts(Post $post, callable $getPosts, callable $storePosts) : void {
    $storePosts([serializePost($post), ...$getPosts()]);
}
</code></pre>

<p>É possível utilizar essa funcionalidade apenas em <em>arrays</em> com chaves numéricas.</p>

<h2><em>Arrow Function</em> - Retornando um autor pelo ID</h2>

<p>Uma das funcionalidades mais esperadas do PHP 7.4 é o <em>Arrow Function</em>, também conhecido como <em>short closure</em>, com ela podemos escrever uma <em>closure</em> de forma mais compacta, sendo assim, no método criado para retornar um autor pelo ID, até a versão 7.3 do PHP teríamos que fazer assim:</p>

<pre><code class="language-php">function getAuthorById(int $authorId) : Author {
    return array_find(getAuthors(), function (Author $author) use ($authorId) {
        return $author-&gt;id === $authorId;
    });
}
</code></pre>

<p>Na versão 7.4 podemos ter o mesmo resultado fazendo da seguinte forma:</p>

<pre><code class="language-php">function getAuthorById(int $authorId) : Author {
    return array_find(getAuthors(), fn(Author $author) =&gt; $author-&gt;id === $authorId);
}
</code></pre>

<p>Essa função <code>array_find</code> foi eu que criei para poder retornar um item do array, e ficou assim:</p>

<pre><code class="language-php">function array_find(array $items, callable $callback) {
    foreach ($items as $item) {
        if ($callback($item)) {
            return $item;
        }
    }
    return false;
}
</code></pre>

<p>Com <em>Arrow Function</em> será possível escrever funções de uma linha menos verbosas. E no futuro, talvez na versão 8 do PHP, podemos ver essa mesma funcionalidade aceitando mais de uma linha.</p>

<h2>Operador de atribuição <em>null coalescing</em> - Recebendo ação do formulário</h2>

<p>Quando iniciei esse blog, <a href="https://whoami.deoliveiralucas.net/blog/iniciando-com-php-7">o primeiro post que publiquei foi sobre a versão 7.0 do PHP</a>, onde o operador <em>null coalescing</em> tinha sido incluído e melhorado a forma de validar e atribuir valores não definidos ou nulo, na versão 7.4 foi incluído o operador de atribuição <em>null coalescing</em> que pode ser utilizado da mesma forma que os operados de mais <code>+=</code>, menos <code>-=</code> e outros já existentes, sendo assim, para obter a ação enviada pelo formulário e deixar a opção padrão para como <code>load</code>, ao invés de fazer isso:</p>

<pre><code class="language-php">$formInputsFromGet['action'] = $formInputsFromGet['action'] ?? 'load';
</code></pre>

<p>Podemos fazer isso na versão 7.4:</p>

<pre><code class="language-php">$formInputsFromGet['action'] ??= 'load';
</code></pre>

<h2>Configurações do ambiente</h2>

<p>Para usar o PHP 7.4 beta usei a imagem do Docker disponível na <a href="https://hub.docker.com/_/php">imagem oficial do PHP no Docker Hub</a>. Se você ainda não utiliza o <a href="https://www.docker.com/resources/what-container">Docker</a>, recomendo pesquise um pouco sobre, instale e comece a utilizar para não precisar ficar instalando várias versões de linguagens, banco de dados, entre outras ferramentas diretamente no sistema operacional da máquina; tenho certeza que vai te ajudar muito, assim como tem me ajudado. Deixei a seguir dois links que podem te ajudar na configuração no Windows e no Linux, caso não saiba como instalar; e já vou avisando que no Linux funciona muito melhor :)</p>

<p><a href="https://www.youtube.com/watch?v=bpbcu36t7g0">Vídeo: Como Instalar o Docker e Docker Compose Ubuntu 18.04</a></p>

<p><a href="https://www.youtube.com/watch?v=OweZAewo54A">Vídeo: Instalando o Docker no Windows</a></p>

<p><a href="https://docs.docker.com/install/">Documentação do Docker: Instalação</a></p>

<p>Com Docker instalado na máquina, primeiro executei um comando que mostra a versão do PHP, isso somente para que seja feito o download das imagens necessárias para executar o container, o comando é o seguinte:</p>

<pre><code class="language-bash">docker run -it --rm -v `pwd`:/php74 -w /php74 -p 8888:8888 php:7.4.0beta1-cli-alpine php -v
</code></pre>

<p>Basicamente o que esse comando faz é, executa um container com a versão 7.4 beta do PHP, mapeia o diretório que está sendo executado o comando com o diretório <code>/app</code> do container, deixa o diretório de workspace do container como <code>/app</code>, mapeia a porta <code>8888</code> do container com a porta <code>8888</code> da máquina e remove o container assim que é finalizado a execução do comando <code>php -v</code>. Para saber como funciona cada parâmetro desse comando, veja <a href="https://docs.docker.com/engine/reference/run/">sobre o comando <em>run</em> na documentação do site oficial do Docker</a>.</p>

<p>Sendo assim, para ficar mais fácil usá-lo vou criar um <em>alias</em> no terminal com prefixo do comando do Docker:</p>

<pre><code class="language-bash">alias php74="docker run -it --rm -v `pwd`:/php74 -w /php74 -p 8888:8888 php:7.4.0beta1-cli-alpine"
</code></pre>

<p>A partir de agora para ver a versão do PHP, podemos apenas executar o comando <code>php74 -v</code>, a saída deve ser o seguinte:</p>

<pre><code class="language-bash">&gt; php74 -v
  PHP 7.4.0beta1 (cli) (built: Aug  2 2019 04:55:36) ( NTS )
  Copyright (c) The PHP Group
  Zend Engine v3.4.0-dev, Copyright (c) Zend Technologies
</code></pre>

<p>E para usar o servidor embutido do PHP:</p>

<pre><code class="language-bash">&gt; php74 -S 0.0.0.0:8888
</code></pre>

<p>Os comandos para executar o código está disponível no README do <a href="https://github.com/deoliveiralucas/php74-beta-tests">repositório no Github</a>.</p>

<h2>Concluindo - Adicionando uma interface ao blog</h2>

<p>Antes de finalizar, vale lembrar que esse post é um visão geral de algumas das novas funcionalidades e melhorias incluídas no PHP 7.4, para saber mais detalhes <a href="https://stitcher.io/blog/new-in-php-74#null-coalescing-assignment-operator-rfc">acesse o artigo publicado no site stitcher.io</a>, nesse artigo é possível saber também quais foram as melhorias de performance e quais funcionalidades estão sendo descontinuadas, além dos links para as <a href="https://wiki.php.net/rfc">RFC's</a> no site oficial do PHP. É isso, e vem muito mais coisas legais nas próximas versões, quem sabe algo como <em>generic array</em> na versão 8, essa é uma das que mais espero.</p>

<p>Por fim, adicionei uma interface web usando um template pronto do Bootstrap.</p>

<p>Lembrando que <a href="https://github.com/deoliveiralucas/php74-beta-tests">o código completo está disponível em um repositório no Github</a> com instruções para clonar e executar.</p>

<h4>Referências</h4>

<ul>
<li><a href="https://www.youtube.com/watch?v=teKnckg5x7I">Talk do Nikita Popov: Typed Properties and more: What’s coming in PHP 7.4?</a></li>
<li><a href="https://stitcher.io/blog/new-in-php-74#null-coalescing-assignment-operator-rfc">Artigo do site stitcher.io: What's new in PHP 7.4</a></li>
<li><a href="https://pensandonaweb.com.br/o-que-ha-de-novo-no-php-7-4/">Artigo do Marcel dos Santos: O que há de novo no PHP 7.4?</a></li>
</ul>
    ]]></content>
</entry>
            <entry>
    <id>https://lucasxciv.dev/blog/2019-05-11-how-to-persist-value-object-with-doctrine-odm</id>
    <link type="text/html" rel="alternate" href="https://lucasxciv.dev/blog/2019-05-11-how-to-persist-value-object-with-doctrine-odm" />
    <title>How to persist Value Object with Doctrine ODM</title>
    <published>2019-06-09T00:00:00+00:00</published>
    <updated>2019-06-09T00:00:00+00:00</updated>
    <author>
        <name>de Oliveira, Lucas</name>
    </author>
    <summary type="html">In this post I describe a short review of Value Object and then show how to apply this concept and persist on the database using Doctrine ODM....</summary>
    <content type="html"><![CDATA[
        <p>I have been working the last couple years with Doctrine ODM in production environment and in some situations I needed to improve my code applying the concept of Value Object/Type, that is a very important pattern to avoid creation of invalid object and to improve the design of the domain code.</p>

<p>In this post I will describe a short review of Value Object/Type and then show how to apply this concept and persist on the database using Doctrine ODM.</p>

<h2>Short review about Value Object/Type</h2>

<p>In some books you can see the author calling this pattern of Value Object and in other of Value Type, in this post from now on I will call it just of Value Object.</p>

<p>Value Objects are small objects that represents a value, two Value Objects with the same state are equals, the main characteristics of a Value Object are that it is immutable and does not have an identity. We can use Value Object to help create a consistent domain model that could be easier to understand, such as, if we create a <code>Money</code> Value Object in our code instead of just using <code>float</code>, we can let all the rules that is relevant to create a money value inside the same object, then if we need to change some of these rules we just go in one place, also all the objects that need a money type will have it already validated, these things can reduce the risk of confusion and duplication.</p>

<p>We can find more about this concept of Value Object in many books or articles, like any books of DDD by Eric Evans or Vaughn Vernon, Refactoring by Martin Fowler, Growing Objects-Oriented Software by Steve Freeman and Nat Pryce, and a many other books and articles that have as the goal improve the software design and consistency.</p>

<p>So, before I start showing the code, let's assume that our Value Object definition is, as described in <a href="https://martinfowler.com/bliki/ValueObject.html">Martin Fowler's article</a>:</p>

<blockquote>
  <p><em>"Objects that are equal due to the value of their properties..."</em></p>
</blockquote>

<h2>Persisting Value Object with Doctrine ODM</h2>

<p>To persist Value Object using Doctrine ODM I can simply use the <a href="https://www.doctrine-project.org/projects/doctrine-mongodb-odm/en/1.2/reference/basic-mapping.html#custom-mapping-types">Custom Mapping Types</a> or <a href="https://www.doctrine-project.org/projects/doctrine-mongodb-odm/en/1.2/reference/annotations-reference.html#embedone">@EmbedOne Annotation</a> that the framework provides. Beyond Doctrine ODM I will also install other two packages, one to create Uuid, that is <a href="https://github.com/ramsey/uuid">ramsey/uuid</a> and other one to help validate the input data, that is <a href="https://github.com/beberlei/assert">beberlei/assert</a>.</p>

<p>For example, if I have a product entity with three properties that are these Value Objects: <code>IdProduct</code>, <code>Name</code> and <code>Price</code>, I can create a custom type for <code>IdProduct</code> and <code>Name</code> that are Value Objects that have only one attribute and the only thing I need to do before persist is convert the object to a MongoDB type, and for <code>Money</code> Value Object I can use the <code>@EmbedOne</code> annotation because it has two attributes, <code>value</code> and <code>currency</code>, so I can do something like this:</p>

<ul>
<li>Entity <code>Product</code>:</li>
</ul>

<pre><code class="language-php">&lt;?php

namespace Store;

use Doctrine\ODM\MongoDB\Mapping\Annotations as ODM;

/** @ODM\Document(collection="Product") */
class Product
{

    /**
     * @ODM\Id(type="product.id", strategy="NONE")
     * @var IdProduct
     */
    private $idProduct;

    /**
     * @ODM\Field(type="product.name")
     * @var Name
     */
    private $name;

    /**
     * @ODM\EmbedOne(name="price", targetDocument="Store\Money")
     * @var Money
     */
    private $price;

    private function __construct()
    {
        $this-&gt;idProduct = IdProduct::instance();
    }

    public function id() : IdProduct
    {
        return $this-&gt;idProduct;
    }

    public function name() : Name
    {
        return $this-&gt;name;
    }

    public function price() : Money
    {
        return $this-&gt;price;
    }

    public static function newProduct(Name $name, Money $price) : self
    {
        $instance = new self();
        $instance-&gt;name = $name;
        $instance-&gt;price = $price;
        return $instance;
    }
}
</code></pre>

<ul>
<li>Value Object <code>ProductId</code>:</li>
</ul>

<pre><code class="language-php">&lt;?php

namespace Store;

use Ramsey\Uuid\Uuid;
use Ramsey\Uuid\UuidInterface;

class IdProduct
{

    /** @var UuidInterface */
    private $uuid;

    private function __construct(UuidInterface $uuid)
    {
        $this-&gt;uuid = $uuid;
    }

    public function toString() : string
    {
        return $this-&gt;uuid-&gt;toString();
    }

    public static function instance() : self
    {
        return new self(Uuid::uuid4());
    }
}
</code></pre>

<ul>
<li>Value Object <code>Name</code>:</li>
</ul>

<pre><code class="language-php">&lt;?php

namespace Store;

use Assert\Assertion;

class Name
{

    /** @var string */
    private $name;

    private function __construct(string $name)
    {
        $this-&gt;name = $name;
    }

    public function toString() : string
    {
        return $this-&gt;name;
    }

    public static function fromString(string $name) : self
    {
        Assertion::minLength($name, 3, 'Name must have at least 3 characters');

        return new self($name);
    }
}
</code></pre>

<ul>
<li>Value Object <code>Money</code>:</li>
</ul>

<pre><code class="language-php">&lt;?php

namespace Store;

use Assert\Assertion;
use Doctrine\ODM\MongoDB\Mapping\Annotations as ODM;

/** @ODM\EmbeddedDocument() */
class Money
{

    /** @var string */
    public const USD = 'USD';

    /**
     * @ODM\Field(name="value", type="float")
     * @var float
     */
    private $value;

    /**
     * @ODM\Field(name="currency", type="string")
     * @var string
     */
    private $currency;

    private function __construct(float $value, string $currency)
    {
        $this-&gt;value = $value;
        $this-&gt;currency = $currency;
    }

    public function value() : float
    {
        return $this-&gt;value;
    }

    public function currency() : string
    {
        return $this-&gt;currency;
    }

    public static function USD(float $value) : self
    {
        Assertion::min($value, 0, 'Money must be positive value');

        return new self($value, static::USD);
    }
}
</code></pre>

<p>And then the Doctrine ODM Custom Types.</p>

<ul>
<li>Custom Type <code>IdProductType</code>:</li>
</ul>

<pre><code class="language-php">&lt;?php

namespace Store\Type;

use Doctrine\ODM\MongoDB\Types\ClosureToPHP;
use Doctrine\ODM\MongoDB\Types\Type;
use Ramsey\Uuid\Uuid;
use Store\IdProduct;

class IdProductType extends Type
{

    use ClosureToPHP;

    public function convertToPHPValue($value)
    {
        return Uuid::fromString((string)$value);
    }

    public function convertToDatabaseValue($value)
    {
        return $value instanceof IdProduct ? $value-&gt;toString() : $value;
    }
}
</code></pre>

<ul>
<li>Custom Type <code>NameType</code>:</li>
</ul>

<pre><code class="language-php">&lt;?php

namespace Store\Type;

use Doctrine\ODM\MongoDB\Types\ClosureToPHP;
use Doctrine\ODM\MongoDB\Types\Type;
use Store\Name;

class NameType extends Type
{

    use ClosureToPHP;

    public function convertToPHPValue($value)
    {
        return Name::fromString((string)$value);
    }

    public function convertToDatabaseValue($value)
    {
        return $value-&gt;toString();
    }
}
</code></pre>

<p>After I created the custom types I have to register it on Doctrine ODM. I can only use the type <code>product.id</code> and <code>product.name</code> on the <code>@Field</code> annotation because it was registered on Doctrine:</p>

<pre><code class="language-php">&lt;?php

use Doctrine\ODM\MongoDB\Types\Type;

Type::addType('product.id', Store\Type\IdProductType::class);
Type::addType('product.name', Store\Type\NameType::class);
</code></pre>

<p>Finally, when I persist the <code>Product</code> entity I will have this result on MongoDB:</p>

<pre><code class="language-js">&gt; db.Product.find().pretty()
{
    "_id" : "fb67f250-d36e-43bd-a0de-4f54f32d67f0",
    "name" : "Notebook",
    "price" : {
        "value" : 1000,
        "currency" : "USD"
    }
}
</code></pre>

<p>I hope this post could have helped you understand how to persist Value Objects using Doctrine ODM, <a href="https://github.com/deoliveiralucas/persist-value-object-doctrine-odm">check out my Github repository</a> if you want to see and execute all the source code.</p>
    ]]></content>
</entry>
            <entry>
    <id>https://lucasxciv.dev/blog/2019-03-19-dicas-para-iniciar-um-projeto-em-php</id>
    <link type="text/html" rel="alternate" href="https://lucasxciv.dev/blog/2019-03-19-dicas-para-iniciar-um-projeto-em-php" />
    <title>Dicas para iniciar um projeto em PHP</title>
    <published>2019-03-19T00:00:00+00:00</published>
    <updated>2019-03-19T00:00:00+00:00</updated>
    <author>
        <name>de Oliveira, Lucas</name>
    </author>
    <summary type="html">No dia 29 de março tive a oportunidade de compartilhar um pouco de minha experiência trabalhando em grandes projetos usando PHP. Na ocasião, falei de alguns problemas que me foram comuns no início dos projetos e apresentei algumas soluções....</summary>
    <content type="html"><![CDATA[
        <p>No último sábado, 16 de março de 2019 na UNISAL em Lorena–SP, tive a oportunidade expor uma apresentação no PHPVale com o tema "Dicas para iniciar um projeto em PHP". Nessa apresentação falei de alguns problemas que me foram comuns -– nesses seis anos de experiência – no início do desenvolvimento dos projetos de software, principalmente trabalhando em aplicações web SaaS escritas em PHP.</p>

<p>Por fim, apresentei algumas soluções para os problemas apresentados, baseados na minha experiência e em publicações de autores diversos. As dicas foram mais focadas para projetos de software visando ser mantido no longo prazo, como dito na apresentação. Apesar dos exemplos mais voltadas para o PHP, elas também podem ser úteis em outras linguagens.</p>

<p>Slides da apresentação: <a href="https://speakerdeck.com/deoliveiralucas/dicas-para-iniciar-um-projeto-em-php">https://speakerdeck.com/deoliveiralucas/dicas-para-iniciar-um-projeto-em-php</a></p>

<h3>Gravação</h3>

<iframe width="100%" height="500vh" src="https://www.youtube.com/embed/wUj6YWp5dmE" frameborder="0" allowfullscreen></iframe>
    ]]></content>
</entry>
            <entry>
    <id>https://lucasxciv.dev/blog/2016-09-18-utilizando-php-7-mongodb-e-doctrine</id>
    <link type="text/html" rel="alternate" href="https://lucasxciv.dev/blog/2016-09-18-utilizando-php-7-mongodb-e-doctrine" />
    <title>Utilizando PHP 7, MongoDB e Doctrine</title>
    <published>2016-09-18T00:00:00+00:00</published>
    <updated>2016-09-18T00:00:00+00:00</updated>
    <author>
        <name>de Oliveira, Lucas</name>
    </author>
    <summary type="html">Nesse post temos uma introdução de como trabalhar com PHP e MongoDB utilizando o framework de persistência Doctrine ODM....</summary>
    <content type="html"><![CDATA[
        <p>Faz um tempo que estou utilizando PHP com MongoDB e faz um tempo também que vi que tinha uma versão do Doctrine que poderia me ajudar com isso, porém quando tinha visto (ano passado) e fui fazer uns testes tive alguns problemas por ainda estar na versão BETA, esses dias resolvi olhar novamente e vi que já faz alguns meses que a versão 1.0 foi lançada e que está até na versão 1.1, então decidi fazer uns testes novamente e compartilhar aqui no blog.</p>

<p>Nesse post vou dar uma introdução de como trabalhar com PHP e MongoDB utilizando o framework de persistência Doctrine ODM. Como exemplo, vou desenvolver um blog simples com posts e comentários, estarei mostrando aqui apenas os códigos da API que estão relacionados com o Doctrine, porém todo o código da aplicação estará disponível e um <a href="http://github.com/deoliveiralucas/blog-php-mongodb-doctrine">repositório no GitHub</a> com um cliente Ajax consumindo a API. Vou utilizar também algumas ferramentas a mais apenas para agilizar o desenvolvimento, como, o micro-framework Silex e o tamplate engine Twig, mas o mesmo procedimento poderá ser facilmente implementado em outros <em>frameworks</em> ou até mesmo em aplicações que utilizam "apenas PHP".</p>

<p>Sendo assim, o blog deverá ter os seguintes recursos na API:</p>

<pre><code class="language-txt">- [POST] /api/post               // Inserir post
- [GET]  /api/post               // Listar dados os posts
- [GET]  /api/post/{id}          // Retornar um post
- [POST] /api/post/{id}/comment  // Inserir comentário no post

- Obs: todos os posts e comentários deverão ser retornados em ordem decrescente por data de criação.
</code></pre>

<p>Primeiro, vamos entender um pouco o que é o Doctrine ODM. O Doctrine ODM (Object Document Mapper) é um framework que foi desenvolvido para o PHP 5.3.0+ e provê uma forma mais transparente de persistir objetos do PHP no MongoDB. Quem já utilizou o Doctrine ORM (Object Relational Mapper), pode ter uma facilidade maior para entender a versão para trabalhar com MongoDB, porém é importante também ter conhecimento especificamente sobre o banco de dados para que se possa utilizar da melhor forma tanto o <em>framework</em> quanto as vantagens que o MongoDB oferece. Caso não conheça e tenha interesse em aprender sobre MongoDB, atualmente existem vários cursos na internet que podem ajudar, porém dois dos que eu fiz, que são gratuitos e que me ajudaram muito, foi o da <a href="http://webschool.io/">Webschool</a> e o da <a href="https://university.mongodb.com/">MongoDB University</a>.</p>

<p>Antes de iniciar o desenvolvimento é necessário ter as seguintes ferramentas instaladas:</p>

<ul>
<li>PHP - Minha versão: 7.1.0</li>
<li>Composer - Minha versão: 1.1.2</li>
<li>MongoDB - Minha versão: 3.0.7 / testei também na versão 3.2.9</li>
</ul>

<p>Logo em seguida é preciso baixar e configurar o Driver do MongoDB para PHP:</p>

<ul>
<li><p>No Windows o download da extensão pode ser feito no <a href="https://pecl.php.net/package/mongodb">site do pecl</a>, depois de ter feito o download, o arquivo <code>.dll</code> deve ser adicionado na pasta <code>ext</code> do PHP e a linha <code>extension=php_mongodb.dll</code> deve ser adicionada no <code>php.ini</code>.</p></li>
<li><p>No Linux o driver pode ser instalado utilizando o <code>pecl</code>, conforme o descrito no repositório do <a href="https://github.com/mongodb/mongo-php-library">mongo-php-library</a>.</p></li>
</ul>

<p>Para verificar se a extensão está instalada, digite o comando <code>php -m</code> no terminal para mostrar a lista de extensões habilitadas, nessa lista deve aparecer <code>mongodb</code>.</p>

<p>Com as ferramentas instaladas e o driver configurado, podemos criar a pasta para iniciar o projeto, no meu caso chamarei de <code>doctrine-odm-blog</code>, feito isso, é necessário criar o arquivo composer.json para instalar as dependências. O arquivo deverá ficar parecido o JSON a seguir.</p>

<pre><code class="language-json">{
    "name": "deoliveiralucas/doctrine-odm-blog",
    "description": "Blog simples com Doctrine ODM e Silex",
    "require": {
        "alcaeus/mongo-php-adapter": "^1.0",
        "doctrine/mongodb": "^1.3",
        "doctrine/mongodb-odm": "^1.1",
        "silex/silex": "^2.0",
        "twig/twig": "~1.0"
    },
    "autoload": {
        "psr-4": {
            "DOLucas\\": "src/"
        }
    },
    "authors": [
        {
            "name": "Lucas de Oliveira",
            "email": "contato@deoliveiralucas.net"
        }
    ]
}
</code></pre>

<p>Note que adicionei também a biblioteca <code>alcaeus/mongo-php-adapter</code>, pelo fato da versão atual do Doctrine ODM (1.3) não suportar a nova versão da extensão do MongoDB para PHP é necessário a instalação desse <em>adapter</em> para que o <em>framework</em> funcione normalmente.</p>

<p>Agora posso instalar as dependências, talvez seja necessário utilizar o parâmetro <code>--ignore-platform-reqs</code>, pois justamente por essa incompatibilidade o Composer pode barrar a instalação:</p>

<pre><code class="language-txt">$ composer install --ignore-platform-reqs
</code></pre>

<p>Depois de instalado, criei mais algumas pastas e arquivos para que a estrutura fique conforme o lista a seguir, lembrando que o objetivo aqui será mostrar apenas os arquivos que estão na pasta <code>Document</code>, <code>Repository</code> e <code>Service</code>.</p>

<pre><code class="language-txt"> |-public
   |-assets
   |-index.php
 |-src
   |-Blog
     |-Controller
       |-PostController.php
     |-Document
       |-Comment.php
       |-Post.php
     |-Factory
       |-CommentFactory.php
       |-PostFactory.php
     |-Repository
       |-PostRepository.php
     |-Service
       |-PostService.php
 |-res
   |-views
     |-create.twig
     |-index.twig
     |-layout.twig
     |-post.twig
 |-vendor
 |-bootstrap.php
 |-composer.json
 |-composer.lock
</code></pre>

<p>Agora vou adicionar o <em>script</em> no arquivo <code>bootstrap.php</code> para criar a conexão com o banco de dados e configurar onde será salvo as classes de <em>Proxies</em> e <em>Hydrators</em> gerados pelo <em>Doctrine</em>, no meu caso deixarei a pasta <code>/tmp</code> e o nome do banco <code>doctrineblog</code>, caso não seja configurado o nome do banco utilizando o método <code>$config-&gt;setDefaultDB</code>, por padrão será criado com o nome <code>doctrine</code>.</p>

<pre><code class="language-php">&lt;?php

require_once __DIR__ . '/vendor/autoload.php';

use Silex\Application;
use Silex\Provider\TwigServiceProvider;
use Doctrine\MongoDB\Connection;
use Doctrine\ODM\MongoDB\Configuration;
use Doctrine\ODM\MongoDB\DocumentManager;
use Doctrine\ODM\MongoDB\Mapping\Driver\AnnotationDriver;

$app = new Application();
$app['debug'] = true;

$app-&gt;register(new TwigServiceProvider(), [
    'twig.path' =&gt; __DIR__ . '/res/views',
]);

// Início da configuração do Doctrine
AnnotationDriver::registerAnnotationClasses();

$config = new Configuration();
$config-&gt;setProxyDir('/tmp');
$config-&gt;setProxyNamespace('Proxies');
$config-&gt;setHydratorDir('/tmp');
$config-&gt;setHydratorNamespace('Hydrators');
$config-&gt;setMetadataDriverImpl(AnnotationDriver::create('/tmp'));
$config-&gt;setDefaultDB('doctrineblog');

$dm = DocumentManager::create(new Connection(), $config);
</code></pre>

<p>No caso acima, a conexão está sendo feita com um banco de dados local, para conectar com um banco remoto, a linha para criar o <code>DocumentManager</code> deve estar da seguinte forma:</p>

<pre><code class="language-php">&lt;?php
$server = "mongodb://user:pass@server:port/dbname";

$dm = DocumentManager::create(new Connection($server), $config);
</code></pre>

<p>Depois de ter criado a conexão, vou criar os arquivos responsáveis por mapear os objetos da minha aplicação com as coleções do banco de dados, assim como no Doctrine ORM é possível fazer isso de forma simples utilizando as anotações, XML ou YAML, nesse exemplo estarei utilizando anotações. Para que as anotações funcionem é necessário que importe a classe <code>Annotations</code> (no caso abaixo foi dado um apelido <code>ODM</code>) e depois informe ao Doctrine que a classe que está sendo criada é um documento do MongoDB com a anotação <code>@ODM\Document</code>, posso informar também qual o nome da coleção que deverá ser armazenado esse documento passando como parâmetro o nome da coleção <code>@ODM\Document(collection="posts")</code>, caso não informe o nome da coleção, ele será criado com o mesmo nome da classe, em seguida posso criar os campos do documento utilizando as anotações.</p>

<p>Como um <em>post</em> deve ter vários comentários é importante destacar o atributo <code>$comments</code> onde está dizendo que deverá referenciar vários documentos (<code>ReferenceMany</code>) utilizando a estratégia (<code>strategy</code>) <code>set</code> que é um comando do MongoDB, o documento alvo (<code>targetDocument</code>) que será referenciado dentro dessa lista é o <code>Comment</code> (uma classe que deverá ser criada), qualquer operação executada no documento pai (<code>Post</code>) poderá refletir nos documentos filhos (<code>Comment</code>) utilizando o parâmetro <code>cascade="all"</code> (<a href="http://docs.doctrine-project.org/projects/doctrine-mongodb-odm/en/latest/reference/reference-mapping.html#cascading-operations">esse opção pode ser personalizada</a>) e por fim, conforme descrito no início do <em>post</em> os comentários retornados deverão estar em ordem decrescente pela data de criação, para isso usamos o parâmetro <code>sort={"createdAt": "desc"}</code>.</p>

<p>Sendo assim, a classe <code>Post</code> deve ficar da seguinte forma:</p>

<pre><code class="language-php">&lt;?php

namespace DOLucas\Blog\Document;

use Doctrine\ODM\MongoDB\Mapping\Annotations as ODM;
use DateTime;

/**
 * @ODM\Document(collection="posts")
 */
class Post
{

    /**
     * @ODM\Id
     */
    private $id;

    /**
     * @ODM\Field(type="string")
     */
    private $title;

    /**
     * @ODM\Field(type="string")
     */
    private $body;

    /**
     * @ODM\Field(type="string")
     */
    private $author;

    /**
     * @ODM\ReferenceMany(
     *    strategy="set",
     *    targetDocument="Comment",
     *    cascade="all",
     *    sort={"createdAt": "desc"}
     * )
     */
    private $comments = [];

    /**
     * @ODM\Field(type="date")
     */
    private $createdAt;

    /**
     * @param string $title
     * @param string $body
     * @param string $author
     */
    public function __construct(string $title, string $body, string $author)
    {
        $this-&gt;setTitle($title);
        $this-&gt;setBody($body);
        $this-&gt;setAuthor($author);
        $this-&gt;setCreatedAt(new DateTime());
    }

    /**
     * @return string
     */
    public function getId() : string
    {
        return $this-&gt;id;
    }

    /**
     * @param string $title
     */
    private function setTitle(string $title)
    {
        $this-&gt;title = $title;
    }

    /**
     * @return string
     */
    public function getTitle() : string
    {
        return $this-&gt;title;
    }

    /**
     * @param string $body
     */
    private function setBody(string $body)
    {
        $this-&gt;body = $body;
    }

    /**
     * @return string
     */
    public function getBody() : string
    {
        return $this-&gt;body;
    }

    /**
     * @param string $author
     */
    private function setAuthor(string $author)
    {
        $this-&gt;author = $author;
    }

    /**
     * @return string
     */
    public function getAuthor() : string
    {
        return $this-&gt;author;
    }

    /**
     * @param Comment $comment
     */
    public function addComment(Comment $comment)
    {
        $this-&gt;comments[] = $comment;
    }

    /**
     * @return array
     */
    public function getComments() : array
    {
        return $this-&gt;comments-&gt;toArray();
    }

    /**
     * @param DateTime
     */
    private function setCreatedAt(DateTime $createdAt)
    {
        $this-&gt;createdAt = $createdAt;
    }

    /**
     * @return DateTime
     */
    public function getCreatedAt() : DateTime
    {
        return $this-&gt;createdAt;
    }
}
</code></pre>

<p>Depois vou mapear a classe <code>Comment</code>:</p>

<pre><code class="language-php">&lt;?php

namespace DOLucas\Blog\Document;

use Doctrine\ODM\MongoDB\Mapping\Annotations as ODM;
use DateTime;

/**
 * @ODM\Document(collection="comments")
 */
class Comment
{

    /**
     * @ODM\Id
     */
    private $id;

    /**
     * @ODM\Field(type="string")
     */
    private $username;

    /**
     * @ODM\Field(type="string")
     */
    private $comment;

    /**
     * @ODM\Field(type="date")
     */
    private $createdAt;

    /**
     * @return string
     */
    public function getId() : string
    {
        return $this-&gt;id;
    }

    /**
     * @param string $title
     */
    public function setTitle(string $title)
    {
        $this-&gt;title = $title;
    }

    /**
     * @param string $username
     */
    public function setUsername(string $username)
    {
        $this-&gt;username = $username;
    }

    /**
     * @return string
     */
    public function getUsername() : string
    {
        return $this-&gt;username;
    }

    /**
     * @param string $comment
     */
    public function setComment(string $comment)
    {
        $this-&gt;comment = $comment;
    }

    /**
     * @return string
     */
    public function getComment() : string
    {
        return $this-&gt;comment;
    }

    /**
     * @param DateTime
     */
    public function setCreatedAt(DateTime $createdAt)
    {
        $this-&gt;createdAt = $createdAt;
    }

    /**
     * @return DateTime
     */
    public function getCreatedAt() : DateTime
    {
        return $this-&gt;createdAt;
    }
}
</code></pre>

<p>Agora que temos nossas classes mapeadas com o banco de dados já é possível utilizá-las, para isso poderíamos fazer da seguinte forma para armazenar e retornar os <em>posts</em> do banco de dados, utilizando o <code>$dm</code> que é o <em>DocumentManager</em> criado no arquivo <code>bootstrap.php</code>:</p>

<pre><code class="language-php">&lt;?php

// criar o post
$post = new Post('Titulo do Post', 'Descrição do post', '@deoliveiralucas');

// avisa ao Doctrine para armazenar o post no próximo flush()
$dm-&gt;persist($post);

// amazena post
$dm-&gt;flush();

// para retornar os posts
$posts = $this-&gt;dm-&gt;getRepository(Post::class)-&gt;findAll();
</code></pre>

<p>Mas para que fique algo mais organizado, criei uma classe chamada <code>PostRepostory</code> que recebe o <em>DocumentManager</em> no construtor. Para realizar as consultas vou utilizar a <a href="http://docs.doctrine-project.org/projects/doctrine-mongodb-odm/en/latest/reference/query-builder-api.html#query-builder-api">Query Builder API</a> que possibilita criar consultas mais personalizadas, pois será necessário retornar o <em>posts</em> em ordem decrescente por data de criação.</p>

<p>Então, a classe <code>PostRepository</code> deve ficar da seguinte forma:</p>

<pre><code class="language-php">&lt;?php

namespace DOLucas\Blog\Repository;

use DOLucas\Blog\Document\Post;
use Doctrine\ODM\MongoDB\DocumentManager;
use Doctrine\ODM\MongoDB\Cursor;

/**
 * @author Lucas de Oliveira &lt;contato@deoliveiralucas.net&gt;
 */
class PostRepository
{

    /**
     * @var DocumentManager
     */
    private $dm;

    /**
     * @var \Doctrine\Common\Persistence\ObjectRepository
     */
    private $queryBuilder;

    /**
     * @param DocumentManager $dm
     */
    public function __construct(DocumentManager $dm)
    {
        $this-&gt;dm = $dm;
        $this-&gt;queryBuilder = $dm-&gt;createQueryBuilder(Post::class);
    }

    /**
     * @param Post $post
     */
    public function save(Post $post)
    {
        $this-&gt;dm-&gt;persist($post);
        $this-&gt;dm-&gt;flush();
    }

    /**
     * @return Cursor
     */
    public function getAll() : Cursor
    {
        return $this
            -&gt;queryBuilder
            -&gt;sort('createdAt', 'desc')
            -&gt;getQuery()
            -&gt;execute();
    }

    /**
     * @param string $id
     * @return Post
     */
    public function getById(string $id) : Post
    {
        return $this
            -&gt;queryBuilder
            -&gt;field('_id')-&gt;equals($id)
            -&gt;getQuery()
            -&gt;getSingleResult();
    }
}
</code></pre>

<p>Com a classe <em>repository</em> e os <em>documents</em> prontos, vou criar mais uma classe chamada <code>PostService</code> que será responsável por inserir as informações que vem da requisição no banco de dados utilizando as classes criadas anteriormente e utilizar o método <code>toArray</code> para mostrar os dados de forma mais limpa na API. Adicionei também as classes <em>Factories</em> que é responsável por instanciar os <em>documents</em> e os <em>Validators</em>. Então a classe <code>PostService</code> com todos os métodos que precisamos, ficou da seguinte maneira:</p>

<pre><code class="language-php">&lt;?php

namespace DOLucas\Blog\Service;

use DOLucas\Blog\Repository\PostRepository;
use DOLucas\Blog\Factory\PostFactory;
use DOLucas\Blog\Factory\CommentFactory;
use DOLucas\Blog\Document\Post;
use DOLucas\Blog\Validator\PostValidator;
use DOLucas\Blog\Validator\CommentValidator;
use Doctrine\ODM\MongoDB\Cursor;
use InvalidArgumentException as ArgumentException;

/**
 * @author Lucas de Oliveira &lt;contato@deoliveiralucas.net&gt;
 */
class PostService
{

    /**
     * @var PostRepository
     */
    private $repository;

    /**
     * @var PostFactory
     */
    private $postFactory;

    /**
     * @var CommentFactory
     */
    private $commentFactory;

    /**
     * @var PostValidator
     */
    private $postValidator;

    /**
     * @var CommentValidator
     */
    private $commentValidator;

    /**
     * @param PostRepository $postRepository
     * @param PostFactory $postFactory
     * @param CommentFactory $commentFactory
     * @param PostValidator $postValidator
     * @param CommentValidator $commentValidator
     */
    public function __construct(
        PostRepository $postRepository,
        PostFactory $postFactory,
        CommentFactory $commentFactory,
        PostValidator $postValidator,
        CommentValidator $commentValidator
    ) {
        $this-&gt;repository = $postRepository;
        $this-&gt;postFactory = $postFactory;
        $this-&gt;commentFactory = $commentFactory;
        $this-&gt;postValidator = $postValidator;
        $this-&gt;commentValidator = $commentValidator;
    }

    /**
     * @param array $params
     */
    public function create(array $params) : array
    {
        try {
            $this-&gt;postValidator-&gt;validate($params);

            $post = $this-&gt;postFactory-&gt;create(
                $params['title'],
                $params['body'],
                $params['author']
            );

            $this-&gt;repository-&gt;save($post);

            return [
                'status'  =&gt; 'success',
                'message' =&gt; 'Post inserido com sucesso'
            ];
        } catch (ArgumentException $e) {
            return [
                'status'  =&gt; 'error',
                'message' =&gt; $e-&gt;getMessage()
            ];
        } catch (Exception $e) {
            return [
                'status'   =&gt; 'error',
                'message'  =&gt; 'Ocorreu um problema ao inserir novo post',
                'internal' =&gt; $e-&gt;getMessage()
            ];
        }
    }

    /**
     * @return array
     */
    public function getAll() : array
    {
        return $this-&gt;toArray($this-&gt;repository-&gt;getAll());
    }

    /**
     * @param string $idPost
     * @return array
     */
    public function getById(string $idPost) : array
    {
        return $this-&gt;toArray($this-&gt;repository-&gt;getById($idPost));
    }

    /**
     * @param string $idPost
     * @param array $params
     * @return array
     */
    public function addComment(string $idPost, array $params) : array
    {
        try {
            $this-&gt;commentValidator-&gt;validate($params);

            $post = $this-&gt;repository-&gt;getById($idPost);

            $comment = $this-&gt;commentFactory-&gt;create(
                $params['username'],
                $params['comment']
            );

            $post-&gt;addComment($comment);

            $this-&gt;repository-&gt;save($post);

            return [
                'status'  =&gt; 'success',
                'message' =&gt; 'Comentário adicionado com sucesso'
            ];
        } catch (ArgumentException $e) {
            return [
                'status'  =&gt; 'error',
                'message' =&gt; $e-&gt;getMessage()
            ];
        } catch (Exception $e) {
            return [
                'status'   =&gt; 'error',
                'message'  =&gt; 'Ocorreu um problema ao adicionar comentário',
                'internal' =&gt; $e-&gt;getMessage()
            ];
        }
    }

    /**
     * @param array|Post $posts
     * @return array
     */
    public function toArray($posts) : array
    {
        $arrPost = [];

        if ($posts instanceof Cursor) {
            foreach ($posts as $post) {
                $arrPost[] = $this-&gt;postToArray($post);
            }

            return $arrPost;
        }

        if ($posts instanceof Post) {
            return $this-&gt;postToArray($posts);
        }

        return $arrPost;
    }

    /**
     * @param Post $post
     * @return array
     */
    protected function postToArray(Post $post) : array
    {
        return [
            'id'        =&gt; $post-&gt;getId(),
            'title'     =&gt; $post-&gt;getTitle(),
            'body'      =&gt; $post-&gt;getBody(),
            'author'    =&gt; $post-&gt;getAuthor(),
            'createdAt' =&gt; $post-&gt;getCreatedAt(),
            'comments'  =&gt; $this-&gt;commentsToArray($post-&gt;getComments())
        ];
    }

    /**
     * @param array $comments
     * @return array
     */
    protected function commentsToArray(array $comments) : array
    {
        $arrComments = [];
        foreach ($comments as $comment) {
            $arrComments[] = [
                'id'        =&gt; $comment-&gt;getId(),
                'username'  =&gt; $comment-&gt;getUsername(),
                'comment'   =&gt; $comment-&gt;getComment(),
                'createdAt' =&gt; $comment-&gt;getCreatedAt()
            ];
        }
        return $arrComments;
    }
}
</code></pre>

<p>O código completo da aplicação está disponível nesse link: <a href="http://github.com/deoliveiralucas/blog-php-mongodb-doctrine">http://github.com/deoliveiralucas/blog-php-mongodb-doctrine</a>.</p>

<p>Podemos ver a facilidade que o Doctrine nos oferece para trabalhar com MongoDB, mas vale ressaltar também que essa facilidade pode trazer uma pouco de perda performance quando comparado com a utilização apenas das classes da extensão do PHP, que também é simples de utilizar.</p>

<p>Eu particularmente já desenvolvi projetos que usam PHP com MongoDB, mas ainda não utilizei o Doctrine ODM pelo motivo de que quando fui pesquisar ainda estava na versão BETA e não quis arriscar, mas se atualmente eu fosse começar um novo projeto, com certeza daria uma atenção maior a esse <em>framework</em>.</p>

<p>A fonte principal desse <em>post</em> foi a documentação oficial do Doctrine ODM, caso queira saber mais recomendo que acesse, pois está bem completa:  <a href="http://docs.doctrine-project.org/projects/doctrine-mongodb-odm/en/latest/">http://docs.doctrine-project.org/projects/doctrine-mongodb-odm/en/latest/</a>.</p>
    ]]></content>
</entry>
            <entry>
    <id>https://lucasxciv.dev/blog/2016-02-13-instanciacao-de-variaveis-no-javascript</id>
    <link type="text/html" rel="alternate" href="https://lucasxciv.dev/blog/2016-02-13-instanciacao-de-variaveis-no-javascript" />
    <title>Instanciação de variáveis no JavaScript</title>
    <published>2016-02-13T00:00:00+00:00</published>
    <updated>2016-02-13T00:00:00+00:00</updated>
    <author>
        <name>de Oliveira, Lucas</name>
    </author>
    <summary type="html">Nesse post veremos algumas funcionalidades fundamentais presentes no Javascript como, por exemplo, a utilização de variáveis....</summary>
    <content type="html"><![CDATA[
        <p>Neste post veremos algumas funcionalidades fundamentais utilizadas em Javascript. Teremos uma introdução sobre Hoisting, Clousure, Variável Global, Variável por parâmetro e Instanciação usando uma IIFE, veremos também alguns exemplos de utilização.</p>

<h2>Hoisting</h2>

<p>Quando uma variável é declarada no Javascript ela é por padrão movida para o topo do escopo atual, ou seja, independente de onde a variável seja declarada no código será o mesmo que declarar no topo, isso é chamado Hoisting. O <strong>Exemplo A</strong>  mostra mais claramente o funcionamento do Hoisting.</p>

<ul>
<li>Exemplo A:</li>
</ul>

<pre><code class="language-js">varDeclarada = 50;

alert(varDeclarada); // Será impresso 50

var varDeclarada;
</code></pre>

<p>É importante deixar claro também que <strong>Inicializar</strong> uma variável é diferente de <strong>Declarar</strong>, conforme mostrado no <strong>Exemplo B</strong>, onde o Hoisting é aplicado apenas para declaração de variáveis.</p>

<ul>
<li>Exemplo B:</li>
</ul>

<pre><code class="language-js">var varInicializada = 20; // Variável inicializada
varDeclarada = 50;

alert('Variável declarada: ' + varDeclarada + '\nVariável inicializada: ' + varInicializada);
// Será impresso "Variável declarada: 50 Variável inicializada: 20"

var varDeclarada; // Variável declarada
</code></pre>

<p>Para funções, tanto o nome quanto o corpo da função é movida para o topo, o <strong>Exemplo C</strong> mostra como funciona.</p>

<ul>
<li>Exemplo C:</li>
</ul>

<pre><code class="language-js">funcaoHoisted(); // Executa a função 'funcaoHoisted' escrita no final do script

function funcaoHoisted() {
  alert('Funciona!');
}
</code></pre>

<h2>Closure</h2>

<p>Um Closure é basicamente uma função criada dentro de outra função (ou função interior) que tem acesso aos parâmetro da função exterior. Em geral, o Closure tem acesso a variáveis do seu próprio escopo, do escopo da função exterior e também as variáveis globais. No <strong>Exemplo D</strong> podemos ver como funciona uma Closure.</p>

<ul>
<li>Exemplo D:</li>
</ul>

<pre><code class="language-js">function funcaoExerior(paramFuncaoExterior) {
    var variavelFuncaoExterior = "Variavel da Função exterior, ";

    function funcaoInterior() {
        var variavelFuncaoInterior = "Variavel da Função interior.";

        return paramFuncaoExterior + variavelFuncaoExterior + variavelFuncaoInterior;
    }

    return funcaoInterior();
}

alert(funcaoExerior("Paramentro função exterior, "));
// será impresso "Paramentro função exterior, Variavel da Função exterior, Variavel da Função interior."
</code></pre>

<h2>Variável Global</h2>

<p>Uma variável Global é declarada fora de um escopo, e quando criada pode ser acessada de dentro de qualquer escopo do código. Desta forma, é importante ter cuidado ao utilizar variável Global. O <strong>Exemplo E</strong> nos mostra o funcionamento de uma variável Global.</p>

<ul>
<li>Exemplo E:</li>
</ul>

<pre><code class="language-js">var variavelGlobal = 1;

function editarVariavelGlobal(){
    ++variavelGlobal;
}

editarVariavelGlobal();
alert(variavelGlobal); // será impresso 2
</code></pre>

<h2>Variável por parâmetro</h2>

<p>Quando passamos variáveis por parâmetro fazemos referência a variáveis que são passadas na assinatura de uma função. Uma variável passada por parâmetro pode ser acessada somente dentro do escopo da própria função, mesmo que a variável seja uma Global, como mostra o <strong>Exemplo F</strong> e <strong>Exemplo G</strong>.</p>

<ul>
<li>Exemplo F:</li>
</ul>

<pre><code class="language-js">function funcao(param1, param2){
    alert('Parametro 1: ' + param1 + ' / Parametro 2: ' + param2);
}

funcao('Argumento1', 'Argumento2'); // será impresso 'Parametro 1: Argumento1 / Parametro 2: Argumento2
</code></pre>

<ul>
<li>Exemplo G:</li>
</ul>

<pre><code class="language-js">var variavelGlobal = 'Global';

function funcao(param1){
    param1 = 'Tentando alterar variavel Global';
}

funcao(variavelGlobal);
alert(variavelGlobal); // será impresso 'Global'
</code></pre>

<h2>Instanciação usando uma IIFE</h2>

<p>O IIFE significa <em>Immediately-invoked function expression</em>, também conhecido como função imediata. Como o nome sugere, ela é uma função que é executada imediatamente após a sua criação. Podemos utilizar IIFE para encapsular funções e variáveis, assim evitamos poluição no nosso escopo global e possíveis conflitos de variáveis ou funções com o mesmo nome.
Instanciação usando uma IIFE pode ser utilizado passando parâmetros ou não, os exemplos <strong>Exemplo H</strong> e <strong>Exemplo I</strong> nos mostram como utilizar.</p>

<ul>
<li>Exemplo H:</li>
</ul>

<pre><code class="language-js">(function() {
    alert('Funciona!!');
})();
</code></pre>

<ul>
<li>Exemplo I:</li>
</ul>

<pre><code class="language-js">(function(param) {
    alert('Funciona!! e com ' + param);
})('parâmetro');
</code></pre>

<h2>Referências</h2>

<ul>
<li><a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Closures">Mozilla</a></li>
<li><a href="http://javascriptbrasil.com/2013/10/12/entenda-closures-no-javascript-com-facilidade">Javascript Brasil</a></li>
<li><a href="http://imasters.com.br/front-end/javascript/sobre-funcoes-imediatas-javascript-iife">iMasters</a></li>
<li><a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">Wikipedia</a></li>
</ul>
    ]]></content>
</entry>
            <entry>
    <id>https://lucasxciv.dev/blog/2016-02-11-trabalhando-com-datas-no-php</id>
    <link type="text/html" rel="alternate" href="https://lucasxciv.dev/blog/2016-02-11-trabalhando-com-datas-no-php" />
    <title>Trabalhando com datas no PHP</title>
    <published>2016-02-11T00:00:00+00:00</published>
    <updated>2016-02-11T00:00:00+00:00</updated>
    <author>
        <name>de Oliveira, Lucas</name>
    </author>
    <summary type="html">Nesse post mostro algumas formas de manipular datas usando PHP....</summary>
    <content type="html"><![CDATA[
        <p>Com o PHP é possível trabalhar com datas de várias formas, podemos utilizar funções, como, <code>date()</code>, <code>time()</code>, <code>strtotime()</code>, <code>mktime()</code>, ou a classe <code>DateTime()</code> que também é muito poderosa e disponibiliza recursos que realmente facilitam muito a manipulação de datas. Além disso, existem várias bibliotecas desenvolvidas pela comunidade PHP que também podem nos ajudar muito quando precisamos manipular datas, porém não será utilizado nesse <em>post</em>, mas que poderá ser conteúdo para um próximo.</p>

<p>Nesse <em>post</em> vou mostrar algumas soluções comuns que podemos encontrar quando precisamos manipular datas.</p>

<h2>Definindo o <em>timezone</em></h2>

<p>Antes de começar a utilizar as funções ou classes do PHP para manipular as datas, é importante configurar o <em>timezone</em> do PHP, pois caso contrário, podemos ter problemas com datas ou horários incorretos, ou ainda ter uma mensagem de <code>E_WARNING</code> toda vez que for utilizar algum recurso do PHP para trabalhar as datas.
Podemos definir o <em>timezone</em> padrão do PHP alterando uma linha no arquivo <code>php.ini</code> de <code>;date.timezone =</code> para <code>date.timezone = America/Sao_Paulo</code> ou adicionando um comando <code>date_default_timezone_set('America/Sao_Paulo');</code> no início do <em>script</em>. Além disso, é possível configurar o PHP de acordo com o seu <em>timezone</em>, conforme mostra a <a href="http://php.net/manual/pt_BR/timezones.php">lista de <em>timezones</em> suportados</a> no site do PHP.</p>

<h2>Diferença de dias entre datas</h2>

<p>Vou mostrar algumas maneiras de encontrar a quantidade de dias entre datas.
A primeira é utilizando o <code>mktime()</code> para pegar o <em>timestamp</em> das datas de início e fim, logo após devemos subtrair a data de fim pela data de início, assim temos o resultado da diferença em <em>timestamp</em>, por último é preciso apenas converter esse resultado para dias.</p>

<pre><code class="language-php">&lt;?php

$dtInicio = '2015-12-01';
$dtFim = '2016-01-01';

$arrDtInicio = explode('-', $dtInicio);
$arrDtFim = explode('-', $dtFim);

$tsInicio = mktime(0, 0, 0, $arrDtInicio[1], $arrDtInicio[2], $arrDtInicio[0]);
$tsFim = mktime(0, 0, 0, $arrDtFim[1], $arrDtFim[2], $arrDtFim[0]);

$tsDiff = $tsFim -$tsInicio;

$quantidadeDias = $tsDiff /86400; // 86400 quantidade de segundos em um dia

echo $quantidadeDias; // 31
</code></pre>

<p>Outra maneira ainda mais simples é utilizando o <code>strtotime()</code>, pois caso a data já esteja no formato correto (<code>yyyy-mm-dd</code>) é necessário apenas passar a data para o <code>strtotime()</code>, pegar o <em>timestamp</em> e fazer o cálculo.</p>

<pre><code class="language-php">&lt;?php

$dtInicio = '2015-12-01';
$dtFim = '2016-01-01';

$tsDiff = strtotime($dtFim) -strtotime($dtInicio);

$quantidadeDias = $tsDiff /86400; // 86400 quantidade de segundos em um dia

echo $quantidadeDias; // 31
</code></pre>

<p>Também podemos utilizar a classe <code>DateTime()</code> que ainda tem uma <a href="http://php.net/manual/en/datetime.diff.php">forma mais simples de formatar a saída</a>.</p>

<pre><code class="language-php">&lt;?php

$dtInicio = '2015-12-01';
$dtFim = '2016-01-01';

$dateTime = new DateTime($dtInicio);
$dateDiff = $dateTime-&gt;diff(new DateTime($dtFim));
$quantidadeDias = $dateDiff-&gt;format('%a');

echo $quantidadeDias; // 31
</code></pre>

<h2>Quantidade de dias uteis</h2>

<p>Com o PHP é bem simples desenvolver uma função para contar a quantidade de dias uteis (seg. à sex.) utilizando o <code>strtotime()</code>. Para isso é preciso obter o <em>timestamp</em> das datas de início e fim, logo em seguida executar um <em>loop</em> que irá verificar se é dia útil ou não, caso seja, será acrescentado um ao contador. Além disso, deixei um parâmetro como opcional para que seja passado os feriados, caso seja necessário.</p>

<p>Executei dois exemplos, o primeiro passei por parâmetro somente o intervalo de datas que gostaria de saber a quantidade de dias uteis, já no segundo exemplo foi passado também um <code>array</code> com as datas referentes aos feriados.</p>

<pre><code class="language-php">&lt;?php

function getDiasUteis($dtInicio, $dtFim, $feriados = []) {
    $tsInicio = strtotime($dtInicio);
    $tsFim = strtotime($dtFim);

    $quantidadeDias = 0;
    while ($tsInicio &lt;= $tsFim) {
        // Verifica se o dia é igual a sábado ou domingo, caso seja continua o loop
        $diaIgualFinalSemana = (date('D', $tsInicio) === 'Sat' || date('D', $tsInicio) === 'Sun');
        // Verifica se é feriado, caso seja continua o loop
        $diaIgualFeriado = (count($feriados) &amp;&amp; in_array(date('Y-m-d', $tsInicio), $feriados));

        $tsInicio += 86400; // 86400 quantidade de segundos em um dia

        if ($diaIgualFinalSemana || $diaIgualFeriado) {
            continue;
        }

        $quantidadeDias++;
    }

    return $quantidadeDias;
}

echo getDiasUteis('2015-12-07', '2016-01-08'); // 25
echo PHP_EOL;

$feriados = [
    '2015-12-25',
    '2015-12-26',
    '2016-01-01'
];

echo getDiasUteis('2015-12-07', '2016-01-08', $feriados); // 23
</code></pre>

<p>Perceba que em nenhum dos exemplos anteriores me importei com a formatação da data, utilizei o formato que normalmente é utilizado pelo banco de dados por padrão, isso por que a seguir veremos algumas maneiras de formatar datas.</p>

<h2>Formatando datas</h2>

<p>É comum quando estamos desenvolvendo algum sistema e precisamos converter datas, por exemplo, do formato do banco de dados para o formato do Brasil, ou vice-versa. Para isso o PHP permite executar essa tarefa de diferentes maneiras, a seguir vou mostrar algumas formas de formatar utilizando funções de data e outras utilizando funções do PHP que não são especificamente para se trabalhar com datas, mas que também funciona :).</p>

<p>Utilizando a classe <code>DateTime()</code></p>

<pre><code class="language-php">&lt;?php

$data = '2016-01-01';
$dateTime = DateTime::createFromFormat('Y-m-d', $data);
$dataFormatada = $dateTime-&gt;format('d/m/Y');
echo $dataFormatada; // 01/01/2016

echo PHP_EOL;

$data = '01/01/2016';
$dateTime = DateTime::createFromFormat('d/m/Y', $data);
$dataFormatada = $dateTime-&gt;format('Y-m-d');
echo $dataFormatada; // 2016-01-01
</code></pre>

<p>Convertendo para o formato do Brasil com o <code>strtotime()</code></p>

<pre><code class="language-php">&lt;?php

$data = '2016-01-01';
$dataFormatada = strtotime('d/m/Y', strtotime($data));

echo $dataFormatada; // 01/01/2016
</code></pre>

<p>Outra forma bem simples é utilizando algumas funções de <code>array</code></p>

<pre><code class="language-php">&lt;?php

$data = '2016-01-01';
$dataFormatada = implode('/', array_reverse(explode('-', $data)));
echo $dataFormatada; // 01/01/2016

echo PHP_EOL;

$data = '01/01/2016';
$dataFormatada = implode('-', array_reverse(explode('/', $data)));
echo $dataFormatada; // 2016-01-01
</code></pre>

<h2>Traduzindo datas com <code>strftime()</code></h2>

<p>Podemos utilizar a função <code>strftime()</code> para exibir as datas em português, já que por padrão as funções retornam as descrições em inglês, para fazer isso precisamos primeiramente configurar o local com a função <code>setlocale()</code> e então utilizar a função <code>strftime()</code> passando o formato e o <em>timestamp</em> como parâmetros para formatar a data, lembrando que o <em>timezone</em> deve estar configurado também.</p>

<pre><code class="language-php">&lt;?php

$tsAtual = time(); // pega timestamp atual

setlocale(LC_ALL, 'pt_BR', 'pt_BR.utf-8', 'portuguese');
$dataTraduzida = strftime('%A, %d de %B de %Y', $tsAtual);

echo $dataTraduzida; // quinta-feira, 11 de fevereiro de 2016

echo PHP_EOL;

$dtInput = strtotime('2015-12-25'); // pega timestamp da data

setlocale(LC_ALL, 'pt_BR', 'pt_BR.utf-8', 'portuguese');
$dataTraduzida = strftime('%A, %d de %B de %Y', $dtInput);

echo $dataTraduzida; // sexta-feira, 25 de dezembro de 2015
</code></pre>

<h2>Utilizando mais <code>strtotime()</code> e <code>DateTime()</code></h2>

<p>A função <code>strtotime()</code> e a classe <code>DateTime()</code> realmente nos ajudam muito a trabalhar com datas, por isso vou mostrar mais algumas de suas funcionalidades, pois acho bem legal a forma que podemos interagir com essas duas ferramentas do PHP.</p>

<pre><code class="language-php">&lt;?php

echo date("d/m/Y", strtotime("next monday")) . PHP_EOL;
echo date("d/m/Y H:i:s", strtotime("2016-01-01 tomorrow noon")) . PHP_EOL;
echo date("d/m/Y H:i:s", strtotime("2016-01-01 tomorrow noon +1 day")) . PHP_EOL;
echo date("d/m/Y", strtotime("2016-01-01 last friday")) . PHP_EOL;

// Saída
// 15/02/2016
// 02/01/2016 12:00:00
// 03/01/2016 12:00:00
// 25/12/2015

$dateTime = new DateTime("now");
echo date("d/m/Y H:i:s", $dateTime-&gt;getTimestamp()) . PHP_EOL;

$dateTime = new DateTime("now +1 month +2 days");
echo date("d/m/Y H:i:s", $dateTime-&gt;getTimestamp()) . PHP_EOL;

$dateTime = new DateTime("today -3 days");
echo date("d/m/Y", $dateTime-&gt;getTimestamp()) . PHP_EOL;

$dateTime = new DateTime("yesterday +1 day");
echo date("d/m/Y", $dateTime-&gt;getTimestamp()) . PHP_EOL;

// Saída
// 11/02/2016 22:33:30
// 13/03/2016 22:33:30
// 08/02/2016
// 11/02/2016
</code></pre>

<h2>Mais informações</h2>

<p>É fundamental entender cada função utilizada nesse <em>post</em> para que se possa ter cada vez mais facilidade para manipular datas. <strong>Lembrando</strong> que é sempre importante validar as datas antes fazer alguma manipulação, nos exemplos desse <em>post</em> não estou validando pois o principal intuído é mostrar como podemos trabalhar com datas.</p>

<p>Nos <em>links</em> a seguir podemos encontrar mais informações sobre cada uma das funções de data utilizadas nos exemplos.</p>

<ul>
<li><a href="http://php.net/manual/pt_BR/function.date.php"><code>date()</code></a></li>
<li><a href="http://php.net/manual/pt_BR/function.strtotime.php"><code>strtotime()</code></a></li>
<li><a href="http://php.net/manual/pt_BR/function.time.php"><code>time()</code></a></li>
<li><a href="http://php.net/manual/pt_BR/function.mktime.php"><code>mktime()</code></a></li>
<li><a href="http://br1.php.net/manual/pt_BR/function.strftime.php"><code>strftime()</code></a></li>
<li><a href="http://php.net/manual/en/class.datetime.php"><code>DateTime()</code></a></li>
</ul>
    ]]></content>
</entry>
            <entry>
    <id>https://lucasxciv.dev/blog/2016-01-26-iniciando-com-php-7</id>
    <link type="text/html" rel="alternate" href="https://lucasxciv.dev/blog/2016-01-26-iniciando-com-php-7" />
    <title>Iniciando com PHP 7</title>
    <published>2016-01-26T00:00:00+00:00</published>
    <updated>2016-01-26T00:00:00+00:00</updated>
    <author>
        <name>de Oliveira, Lucas</name>
    </author>
    <summary type="html">Inicio esse blog testando e descrevendo sobre algumas das novas funcionalidades do PHP 7....</summary>
    <content type="html"><![CDATA[
        <p>Se você programa em PHP ou acompanha as notícias sobre desenvolvimento, deve estar sabendo que o PHP 7 foi oficialmente lançado a quase dois meses, e para você que ainda não viu as novas características ou quer saber um pouco mais, continue lendo este <em>post</em>, pois resolvi iniciar esse blog escrevendo e testando algumas de suas novas funcionalidades.<!-- more --> No momento que estou escrevendo este <em>post</em>, já li vários artigos sobre o PHP 7, por sinal a grande maioria muito bom, já recebi até e-mail de cursos completos que dizem ser totalmente voltado para essa nova versão.</p>

<p>Então vamos lá! vamos ver o que tem de novo e quais são algumas das incompatibilidades com as versões anteriores.</p>

<h2>Scalar Types</h2>

<p>Primeiramente queria falar de duas novas características que eu particularmente aguardava, que é a possibilidade declarar o tipo de valor a ser passado por parâmetro utilizando <code>string</code>, <code>int</code>, <code>float</code> e <code>bool</code>, na versão 5 era possível utilizar apenas <code>array</code> e objetos.</p>

<p>Com essa nova característica podemos criar códigos bem mais consistentes, ter mais facilidade para trabalhar em equipe e ter menos erros.</p>

<p>Então, agora é possível fazer algo desse tipo:</p>

<pre><code class="language-php">&lt;?php
function soma(int $x, int $y) {
    return $x + $y;
}
</code></pre>

<h2>Declaração de tipo de retorno</h2>

<p>E o que eu mais aguardava que era a possibilidade de declarar o tipo do valor de retorno em uma função ou método. É bem simples utilizar este novo recurso, basta adicionar dois pontos <code>:</code> e o tipo de retorno (<code>int</code>, <code>string</code>, etc..) após fechar o parenteses dos parâmetros e o tipo valor de retorno já está declarado. Caso o tipo de valor retornado não seja o mesmo que o declarado, o PHP irá disparar um <code>Fatal error</code>.</p>

<p>Sendo assim, com o PHP 7 podemos criar funções declarando o tipo de retorno da seguinte maneira.</p>

<pre><code class="language-php">&lt;?php
function soma(int $x, int $y) : int {
    return $x + $y;
}
</code></pre>

<h2>Operador <em>Null coalescing</em> <code>??</code></h2>

<p>Acredito que essa seja uma característica que realmente será muito útil e poderá deixar o código mais limpo, apesar de fazer algo bem simples.
Se você costuma escrever código como do exemplo a seguir para testar a existência de uma variável e atribuir um valor, será muito útil pra você:</p>

<pre><code class="language-php">&lt;?php
$usuario = isset($dados['usuario']) ? $dados['usuario'] : 'anonimo';
</code></pre>

<p>No PHP 7 poderá ter a mesma funcionalidade escrevendo o seguinte código:</p>

<pre><code class="language-php">&lt;?php
$usuario = $dados['usuario'] ?? 'anonimo';
</code></pre>

<p>Realmente reduziu ainda mais a quantidade de código, ficou simples e ainda no meu ponto de vista deixa o código mais limpo, muito bom!</p>

<h2>Operador <em>Spaceship</em> <code>&lt;=&gt;</code></h2>

<p>Este novo operador <em>spaceship</em> que é representado por <code>&lt;=&gt;</code>, é usado para comparação de duas expressões, podendo ser numérico ou não. A utilização desse operador retorna -1 se o valor da esquerda for menor que o da direita, 0 se os valores forem iguais e 1 se o da esquerda for maior que o da direita, conforme mostra o exemplo a seguir:</p>

<pre><code class="language-php">&lt;?php
var_dump(2&lt;=&gt;3); // int(-1)
var_dump(2&lt;=&gt;2); // int(0)
var_dump(2&lt;=&gt;1); // int(1)

var_dump("A"&lt;=&gt;"a"); // int(-1)
var_dump("a"&lt;=&gt;"a"); // int(0)
var_dump("a"&lt;=&gt;"A"); // int(1)
</code></pre>

<h2>Criar uma constante <code>array</code> usando <code>define()</code></h2>

<p>Com o PHP 7 é possível armazenar um <code>array</code> em uma constante e então recuperar os valores pelo índice. Na versão 5.6 também é possível fazer isso, mas apenas utilizando <code>const</code>.</p>

<pre><code class="language-php">&lt;?php
define('USUARIO', [
    'nome',
    'sobrenome',
    'email'
]);

echo USUARIO[1]; // sobrenome
</code></pre>

<h2>Classes anônimas</h2>

<p>No PHP 7 foi introduzido também a possibilidade de utilizar classes anônimas, em versões anteriores era possível fazer isso com funções.
Podemos utilizar classes anônimas quando queremos criar uma classe, utilizar apenas uma vez e então descartar.</p>

<p>Um exemplo que achei interessante é da utilização com os <em>Patterns</em> <em>Subject</em> e <em>Observer</em>.</p>

<pre><code class="language-php">&lt;?php
interface IObserver {
    public function update(ISubject $subject);
}

interface ISubject {
    public function attach(IObserver $observer);
    public function detach(IObserver $observer);
    public function notify();
}

class ClienteSubject implements ISubject {
    protected $observers = [];

    public function attach(IObserver $observer) {
        $this-&gt;observers[] = $observer;
    }

    public function detach(IObserver $observer) {
        // ...
    }

    public function notify() {
        foreach ($this-&gt;observers as $observer) {
            $observer-&gt;update($this);
        }
    }

    public function updateNome($nome) {
        $this-&gt;nome = $nome;
        $this-&gt;notify();
    }

    public function getNome() {
        return $this-&gt;nome;
    }
}

$cliente = new ClienteSubject();

// Agora vamos usar uma classe anônima
$cliente-&gt;attach(new class implements IObserver {
    public function update(ISubject $subject) {
        printf('Cliente %s atualizado', $subject-&gt;getNome());
    }
});

$cliente-&gt;updateNome("Teste classe anônima");
</code></pre>

<h2>Agrupando declarações de <code>use</code></h2>

<p>Com o PHP 7 é possível agrupar a importação de classes de um mesmo <code>namespace</code>.</p>

<pre><code class="language-php">&lt;?php
use exemplo\namespace\ {
    ClasseA as a,
    ClasseB,
    ClasseC
};
</code></pre>

<h2>Construtor depreciado PHP 4</h2>

<p>Não sei se você conhecia ou já tinha utilizado este tipo de construtor, pois foi introduzido na versão 4 do PHP e não é comum ser utilizado atualmente, mas é possível criar um construtor utilizando o mesmo nome da classe como é feito em outras linguagens de programação, porém essa funcionalidade a partir da versão 7 está depreciada e irá emitir um <code>E_DEPRECATED</code> caso seja utilizada, e será removida em futuras versões do PHP.
O recomendado é que utilize <code>__construct</code> para criação de construtores.</p>

<pre><code class="language-php">&lt;?php
class Exemplo {
    public function Exemplo() {
        echo 'Construtor executado';
    }
}
</code></pre>

<h2>Extensão <code>mysql</code> removida</h2>

<p>A extensão <code>mysql</code> foi removida na versão 7 do PHP, essa que já é uma função que vinha emitindo uma mensagem de <code>E_DEPRECATED</code> desde versão 5.6, e a partir da versão 7 não será mais utilizada. Essa extensão foi removida principalmente por problemas relacionados a segurança.</p>

<h2>Chamar métodos estáticos sem <code>static</code></h2>

<p>O PHP aceita que chame métodos como estáticos mesmo que não seja declarado como <code>static</code>, porém isso a partir da versão 7 está emitindo uma mensagem de <code>E_DEPRECATED</code> e será removido no futuro.</p>

<pre><code class="language-php">&lt;?php
class Classe {
    function metodo() {
        echo 'Não sou um método estático!';
    }
}

Classe::metodo();
</code></pre>

<h2>Desempenho</h2>

<p>Claro que eu não poderia deixar de falar do incrível desempenho que o PHP 7 vem demostrando em diversos <em>benchmarks</em> que estão sendo realizados tanto por usuários da linguagem quanto pela própria <a href="http://www.zend.com/en/resources/php7_infographic">Zend</a>. Com o nova versão do motor <em>Zend Engine</em> o PHP vem mostrando um grande aumento no desempenho quando comparado com a versão 5.6 ou até mesmo com o HHVM que é a versão do PHP criada pelo <em>facebook</em> justamente para ter melhor performance.</p>

<h2>Quer saber mais?</h2>

<p>O PHP incluiu varias outras características na nova versão, caso você tenha se interessado e queira saber mais, pode dar uma olhada no site oficial <strong><a href="http://php.net">php.net</a></strong>, lá você encontra tudo que foi adicionado, alterado e removido. O que eu mostrei aqui foi algumas dessas novas características que achei interessante, espero que tenha gostado, qualquer dúvida ou sugestão, pode me mandar.</p>

<p><strong>Referência</strong>: <a href="http://php.net">php.net</a></p>
    ]]></content>
</entry>
    </feed>
